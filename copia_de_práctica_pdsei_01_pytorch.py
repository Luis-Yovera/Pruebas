# -*- coding: utf-8 -*-
"""Copia de Práctica PDSeI 01 - Pytorch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oR_N8PTqEKBB2-gPIDNFOcf6W7Ra1glA

# Pytorch


"""## Importar dependencias"""

import torch
import torch.nn as nn
import torchvision.datasets as dsets
import torchvision.transforms as transforms
from torch.autograd import Variable

"""## Definir Hiperparámetros"""

input_size = 784
hidden_size = 256  # Aumentado de 128 a 256
num_classes = 10
num_epochs = 20  # Aumentado de 5 a 20
batch_size = 64  # Ajustado de 100 a 64
lr = 5e-3  # Aumentado de 1e-3 a 5e-3

"""## Descargando la base de datos mnist"""

train_data = dsets.FashionMNIST(root = './data', train = True,
                        transform = transforms.ToTensor(), download = True)  #Contiene el conjunto de imágenes y etiquetas del conjunto de entrenamiento
                                                                              #  Contiene imágenes de prendas de ropa  //   28x28 píxeles
test_data = dsets.FashionMNIST(root = './data', train = False,
                       transform = transforms.ToTensor()) #Contiene el conjunto de imágenes y etiquetas del conjunto de prueba

"""## Leyendo la data"""

train_gen = torch.utils.data.DataLoader(dataset = train_data,
                                             batch_size = batch_size,
                                             shuffle = True)            #Es un DataLoader que gestiona los datos de entrenamiento, dividiéndolos en lotes de tamaño batch_size y barajando las muestras aleatoriamente para cada época.

test_gen = torch.utils.data.DataLoader(dataset = test_data,
                                      batch_size = batch_size,
                                      shuffle = False)                  # Es Es un DataLoader que gestiona los datos de prueba, también dividiéndolos en lotes de tamaño batch_size, pero sin barajar los datos.

"""## Definir modelo"""

class Net(nn.Module):
  def __init__(self, input_size, hidden_size, num_classes):
    super().__init__()
    self.fc1 = nn.Linear(input_size, hidden_size)
    self.relu = nn.ReLU()
    self.drop = nn.Dropout(0.2)
    self.fc2 = nn.Linear(hidden_size, num_classes)

  def forward(self,x):
    out = self.fc1(x)
    out = self.relu(out)
    out = self.drop(out)
    out = self.fc2(out)
    return out

"""## Instancia del modelo"""

net = Net(input_size, hidden_size, num_classes)

if torch.cuda.is_available():
  net.cuda()

"""## Compilación"""

loss_function = nn.CrossEntropyLoss()
optimizer = torch.optim.Adam(net.parameters(), lr=lr)

"""## Entrenamiento"""

# Commented out IPython magic to ensure Python compatibility.
for epoch in range(num_epochs):
  for i, (images, labels) in enumerate(train_gen):
    images = images.view(-1, 28*28).cuda()
    labels = labels.cuda()

    optimizer.zero_grad()
    outputs = net(images)
    loss = loss_function(outputs, labels)
    loss.backward()
    optimizer.step()

    if (i + 1) % 100 == 0:
        print('Epoca [%d/%d], Step [%d/%d], Loss: %.4f'
#               % (epoch + 1, num_epochs, i + 1, len(train_data) // batch_size, loss.item()))

correct = 0
total = 0
for images, labels in test_gen:
    images = images.view(-1, 28*28).cuda()
    labels = labels.cuda()

    output = net(images)
    _, predicted = torch.max(output, 1)
    correct += (predicted == labels).sum()
    total += labels.size(0)

print('Accuracy: %.3f %%' % (100 * correct / (total + 1)))